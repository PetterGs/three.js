<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - standard</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl bent normalmap bounce approximation<br/>
			<a href="https://sketchfab.com/3d-models/lowe-4522a4cdc1c14190bf1a8811fa27da32" target="_blank" rel="noopener">Löwe model</a> by noe-3d.at CC0
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';	

			import Stats from './jsm/libs/stats.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js'
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js'
			import { RGBELoader } from './jsm/loaders/RGBELoader.js';
			import { TransformControls } from './jsm/controls/TransformControls.js'

			const statsEnabled = true;

			let container, stats;

			let camera, scene, renderer, controls, pmremGenerator, environmentGui, materialGui;

			let pointLight, lightGizmo;

			const environments = {

				'Venice Sunset': { filename: 'venice_sunset_1k.hdr' },
				'Overpass': { filename: 'pedestrian_overpass_1k.hdr' },
				'None': undefined

			};

			let model;
			const materialPresets = ['White marble', 'Polished bronze', 'Red porcelain', 'Stone', 'Polished gold', 'Red plastic']
			const params = {

				'Map': Object.keys( environments )[ 0 ],
				'Rotation': 1.0,
				'Bent normal map': false,
				'Material preset': materialPresets[2],
				'AO intensity': 1.0,
				'Point light': false,
				'Reflection multiplier': 4.01,
				'Bounce power multiplier': 0.85,
				'Bounce blur multiplier': 2.001,

			};

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 3;

				//

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.y = 1.25;
				camera.position.x = -2;
				camera.position.z = 2;
				scene.add( camera );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enablePan = false
				controls.rotateSpeed = 0.5
				controls.target = new THREE.Vector3(0, 0.8, 0)

				//

				pointLight = new THREE.PointLight(0xffffff, 1.5, 100, 2)
				lightGizmo = new TransformControls(camera, renderer.domElement)
				lightGizmo.addEventListener('dragging-changed', function (event) { controls.enabled = !event.value })
				scene.add(lightGizmo)
				scene.add(pointLight)
				pointLight.position.set(-1.5, 0.5, -1.5)
				lightGizmo.attach(pointLight)
				lightGizmo.enabled = params['Point light']
				lightGizmo.visible = params['Point light']
				pointLight.visible = params['Point light']

				//

				const material = new THREE.MeshStandardMaterial();

				new GLTFLoader()
					.setPath( 'models/gltf/Löwe/' )
					.load( 'model.glb', function ( gltf ) {

						const loader = new THREE.TextureLoader()
							.setPath( 'models/gltf/Löwe/' );

						material.roughness = 1;
						material.metalness = 0;

						const albedoMap = loader.load( 'albedo.png' );
						albedoMap.encoding = THREE.sRGBEncoding;
						material.oldAlbedoMap = albedoMap;
						material.map = albedoMap;
						material.map.flipY = false;

						material.normalMap = loader.load( 'normals.png' );
						material.normalMap.flipY = false;

						const bentNormalMap = loader.load( 'bentNormals.png' );
						bentNormalMap.flipY = false;
						material.oldBentNormalMap = bentNormalMap;
						material.bentNormalMap = { value: params['Bent normal map'] ?  material.oldBentNormalMap : null }

						material.aoMap = loader.load( 'occlusion.png');
						material.aoMap.flipY = false;

						material.vertexTangents = false;

						gltf.scene.traverse(function (child) {
							if (child.isMesh) {
								child.frustumCulled = false;
								child.material = material;
								model = child;
							}
						} );

						scene.add( gltf.scene );

						setMaterialPreset(materialPresets[2]);

					} );
					
				pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

				addGui();

				loadEnvironment( params['Map']);

				if ( statsEnabled ) {

					stats = new Stats();
					container.appendChild( stats.dom );

				}

				window.addEventListener( 'resize', onWindowResize );

			}

			function loadEnvironment(name) {

				if( !environments[ name ] ) {

					scene.background = null;
					scene.environment = null;
					environmentGui.pointLight.setValue(true)
					return;

				}

				if ( environments[ name ].texture !== undefined ) {

					scene.background = environments[ name ].texture;
					scene.environment = environments[ name ].texture;
					return;

				}

				const filename = environments[ name ].filename;
				new RGBELoader()
				.setDataType( THREE.UnsignedByteType )
				.setPath( 'textures/equirectangular/' )
				.load( filename, function ( hdrEquirect ) {

					const hdrCubeRenderTarget = pmremGenerator.fromEquirectangular( hdrEquirect );
					hdrEquirect.dispose();

					scene.background = hdrCubeRenderTarget.texture;
					scene.environment = hdrCubeRenderTarget.texture;
					environments[ name ].texture = hdrCubeRenderTarget.texture;

				} );

			}

			function addGui() {
				const gui = new GUI();

				environmentGui = gui.addFolder('Environment');
				environmentGui.map = environmentGui.add( params, 'Map', Object.keys( environments ) ).onChange( function( value ) {
					loadEnvironment(value);
				} );
				environmentGui.rotation = environmentGui.add(params, 'Rotation').min(0).max(1).onChange((value) => {
					lightGizmo.visible = false;
					lightGizmo.enabled = false;
					pointLight.visible = false;
					scene.rotation.y = Math.PI * 2 * value;
					if( value < 1) environmentGui.pointLight.setValue(false)
				})
				environmentGui.pointLight = environmentGui.add(params, 'Point light').onChange((value) => {
					if(value) {
						if( params['Rotation'] < 1) environmentGui.rotation.setValue(1.0);
					}
				
					lightGizmo.visible = value;
					lightGizmo.enabled = value;
					pointLight.visible = value;

				})
				environmentGui.open();

				materialGui = gui.addFolder('Material');
				materialGui.bentNormalMap = materialGui.add(params, 'Bent normal map').onChange((value) => {
					model.material.bentNormalMap = value ? model.material.oldBentNormalMap : null;
					model.material.needsUpdate = true;
				})
				materialGui.materialPreset = materialGui.add(params, 'Material preset', materialPresets).onChange(function (value) {
					setMaterialPreset(value);
				})
				materialGui.ambientOcclusionIntensity = materialGui.add(params, 'AO intensity').min(0).max(1).onChange((value) => {
					model.material.aoMapIntensity = value;
				})
				materialGui.reflectionOcclusionMultiplier = materialGui.add(params, 'Reflection multiplier').min(0).max(6).onChange((value) => {
					if(model.material.reflectionOcclusionMultiplier) model.material.reflectionOcclusionMultiplier = value;
				})
				materialGui.bouncePowerMultiplier = materialGui.add(params, 'Bounce power multiplier').min(0).max(1).onChange((value) => {
					if(model.material.bouncePowerMultiplier) model.material.bouncePowerMultiplier = value;
				})
				materialGui.bounceBlurMultiplier = materialGui.add(params, 'Bounce blur multiplier').min(0.001).max(6).onChange((value) => {
					if(model.material.bounceBlurMultiplier) model.material.bounceBlurMultiplier = value;
				})
				materialGui.open();

				gui.open();
				gui.width = 370;

			}

			function setMaterialPreset (preset) {
				if (preset === 'White marble') {
					model.material.color.copy({ r: 240, g: 240, b: 242 }).multiplyScalar(1 / 255);
					model.material.map = null;
					model.material.roughness = 0.87;
					model.material.metalness = 0;
				} else if (preset === 'Polished bronze') {
					model.material.color.copy({ r: 198, g: 112, b: 79 }).multiplyScalar(1 / 255);
					model.material.map = null;
					model.material.roughness = 0.26;
					model.material.metalness =  1;
				} else if (preset === 'Red plastic') {
					model.material.color.copy({ r: 248, g: 1, b: 2 }).multiplyScalar(1 / 255);
					model.material.map = null;
					model.material.roughness = 0.3;
					model.material.metalness = 0;
				} else if (preset === 'Red porcelain') {
					model.material.color.copy({ r: 181, g: 0, b: 0 }).multiplyScalar(1 / 255);
					model.material.map = null;
					model.material.roughness = 0.15;
					model.material.metalness = 0;
				} else if (preset === 'Stone') {
					model.material.color.copy({ r: 255, g: 255, b: 255 }).multiplyScalar(1 / 255);
					model.material.map = model.material.oldAlbedoMap;
					model.material.roughness = 0.6;
					model.material.metalness = 0;
				} else if (preset === 'Polished gold') {
					model.material.color.copy({ r: 242, g: 208, b: 89 }).multiplyScalar(1 / 255);
					model.material.map = null;
					model.material.roughness = 0.17;
					model.material.metalness = 1;
				}

				materialGui.bentNormalMap.setValue(true)
				materialGui.ambientOcclusionIntensity .setValue(1)
				materialGui.reflectionOcclusionMultiplier.setValue(4.01)
				materialGui.bouncePowerMultiplier.setValue(0.85)
				materialGui.bounceBlurMultiplier.setValue(2.001)

				model.material.needsUpdate = true;
			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();
				renderer.render( scene, camera );

				if ( statsEnabled ) stats.update();

			}

		</script>

	</body>
</html>
